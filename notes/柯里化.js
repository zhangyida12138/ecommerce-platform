// 1.执行上下文
// 执行上下文是js执行代码时的环境,包含了当前代码执行时所需要的一切信息.
// 不是一块单独的内存区域,是一种抽象概念
// 管理着各种变量,函数,this绑定以及作用域的管理.
//在js执行代码时,执行上下文会被压入执行栈,也叫调用栈,执行完会被弹出.
// 执行上下文和js文件中并没有一一对应的关系.

// 2.执行上下文的总类:
// 全局执行上下文,在运行js文件时,通常只有一个全局执行上下文.
// 不同模块会有自己的执行上下文,但是他们仍然属于一个全局执行上下文.
// 函数执行上下文,函数被调用时.
// eval执行上下文,执行eval函数时.

// 3.执行上下文的组成:
// 变量对象,是一个储存了当前上下文中所有的变量,函数参数和声明的函数的对象.在全局上下文中,变量对象就是全局对象.
// 作用域链
// this,指向当前执行上下文的上下文环境,就是当前执行上下文所绑定的对象.
// 在全局上下文中,this就绑定的是全局对象.
// 在函数执行上下文中,this的值依赖于函数的调用方式:
// 如果是普通函数调用,this就执行全局对象
// 如果是方法调用obj.func(),this指向调用的方法对象
// 在构造函数中，this绑定新指向的实例对象。

// 4.什么是作用域？
// 作用域决定了在代码中可以访问哪些变量和函数。简单来说，它就是代码中可以“看见”变量、函数的区域。

// 5. 作用域的种类：
// 全局作用域：全局范围内定义的变量和函数可以在任何地方被访问。
// 函数作用域：每个函数都有自己的作用域，在函数内部声明的变量和函数只能在函数内部访问。
// 块级作用域（ES6 引入）：let 和 const 定义的变量只能在代码块（如 if、for）内部访问。

// 6.作用域链：
// 当访问一个变量时，JavaScript 会从当前的作用域开始查找，如果找不到，就会去外层作用域继续查找，直到全局作用域。这个查找机制形成了作用域链。
var a = 10;

function outer() {
    var b = 20;

    function inner() {
        var c = 30;
        console.log(a, b, c); // 10, 20, 30
    }
    inner();
}

outer();

// 7.闭包的用途：
// 数据封装：可以创建私有变量，外部无法直接访问。
// 记住外部环境的变量：例如，延迟执行、异步操作等。可以实现持久化的操作
function outer() {
    var count = 0;  // `count` 是一个局部变量
    return function inner() {
        count++;
        console.log(count);
    }
}

const counter = outer(); // 返回闭包
counter();  // 1
counter();  // 2
counter();  // 3

// 7.5词法作用域：
// 词法作用域是指函数的作用域在函数创建时就已经确定，而不是在函数执行时决定。
// 也就是说，JavaScript 引擎会根据函数的定义位置来确定它的作用域链。
// 词法作用域的规则决定了一个函数可以访问外部函数的变量，甚至在外部函数执行完毕后，这些变量依然可以在内部函数中访问。

// 8.什么是柯里化？
// 柯里化是一种将多参数函数转化为一系列单参数函数的技术。每次调用返回一个新函数，直到所有参数都传递完毕为止。它可以通过链式调用的方式逐步传递参数。

// 9/柯里化的用途：
// 简化函数调用：通过逐步传递参数，可以创建更加灵活和可组合的函数。
// 部分应用：可以通过固定一些参数来创建更具体的函数。
function add(a) {
    return function(b) {
        return a + b;
    }
}

const add5 = add(5);  // 固定参数a为5
console.log(add5(3));  // 8
console.log(add5(10)); // 15
