// 1.OSI七层模型：
// 物理层，例如网线，电缆，wifi无线电波，传输的二进制数据
// 数据链路层，例如网卡，交换机。保证数据的可靠传输，防止数据丢失和顺坏，并负责错误检测和纠正
// 网络层，路由器工作在这一次，常用IP协议，负责数据包的路由选择和转发。
// 传输层，TCP，UDP协议，提供可靠的端对端的数据传输服务
// 会话层 管理应用程序之间的会话，控制会话的建立、维护和终止。
// 表示层 数据的格式化和加密解密。它处理数据的表示形式和数据压缩等操作。SSL/TLS
// 应用层 http，通过tcp连接建立的

// TCP：面向连接的协议，提供可靠数据传输，但是速度慢。
// 三次握手
// 第一次：客户端发送SYN，请求建立连接。
// 第二次：服务器回复SYN+ACK，表示同意建立连接。
// 第三次：客户端回复ACK，连接建立成功。

// 四次挥手
// 第一次：客户端发送FIN，表示请求关闭连接。
// 第二次：服务器回复ACK，表示收到关闭请求，但仍然继续发送数据。
// 第三次：服务器发送FIN，表示没有数据要发送，准备关闭连接。
// 第四次：客户端回复ACK，连接关闭。

// 可靠性机制
// TCP通过流量控制、拥塞控制、重传机制等保证数据传输的可靠性，确保数据按顺序到达，防止丢失或乱序。

// UDP:无连接的协议，数据不可靠，数据可能丢失或者乱序，不需要建立连接，但是速度快。缺乏流量控制和错误校验。
// 无连接，不保证顺序和可靠性

// HTTP：应用层协议，通过TCP连接建立的
// SSL/TLS：加密协议，和http结合成https
// TLS是SSL的后续版本

// HTTP请求：强烈建议使用https
// GET请求，幂等性，安全性。没有请求体 ，多次指向同一个get不会修改服务器状态，也不会对服务器资源造成更改。请求可以被缓存，以提高性能
// POST请求，没有幂等性，数据不通过url进行传输，通过请求体进发送数据，相对安全。POST请求一般不进行缓存。
// PUT请求，更新数据，通常是替换，幂等性，通过请求体进行传输
// DELETE请求，幂等性，没有请求体，通过url
// PATCH请求，修改部分数据，不是幂等的，有请求体
// HEAD请求只返回响应头，和GET类似，幂等

// HTTP的缓存控制
// 用于减少重复的网络请求，减少延迟和带宽的消耗。
// 主要作用于响应体，也有缓存请求的情况，例如请求头的缓存和重用。

// HTTP/1.x和HTTP2的主要区别
// HTTP1每一个请求都是独立的TCP连接，一个请求完成后才能发送下一个请求，而HTTP2引入了多路复用，允许同一个TCP连接上同时并行多个请求和响应，不会相互阻塞。
// HTTP1中的请求头和响应头都是纯文本的形式传输的，每个请求和响应都要重复传输完整的头部信息，会造成不必要的带宽浪费。HTTP2引入了HPACK压缩算法来对请求和响应头进行压缩，减少了头部信息的传输量，提高了传输效率。
// HTTP1是请求响应模型，客户端发送请求，服务器返回响应，无法提前推送数据，而HTTP2引入了服务器推送机制，服务器可以在响应客户端请求时，提前推送一些额外资源js，css，减少后续请求。
// HTTP1没有内置的流控制机制，不考虑传输中的数据流速和带宽，而HTTP2有流控制，可以允许客户端和服务器之间更细粒度的控制传输速度。

// 预检请求 preflight
// 浏览器发送跨域请求之前，自动发送的一个预检请求Option请求，来验证服务器是否允许特定的跨域请求。
// 服务器响应了允许的跨域请求，才会发送实际请求。每次涉及到跨域的请求时，浏览器都会自动发送预检请求

// 需要用到preflight的情况：
// 1.请求方法是非简单方法，例如PUT，DELETE,PATCH.(GET,POST,HEAD是简单方法)
// 2.请求中的Content-Type是非简单类型，例如application/json.(text/plain,multipart/form-data，application/x-www-form-urlencoded是简单类型)。
// 3.请求包含自定义头部，如Authorization，X-Custom-Header等。

// 在请求头中设置connection：keep-alive，服务器在响应头中也加入Connection：keep-alive可以保持连接
// 可以通过设置Keep-Alive头中的timeout和max字段来指定保持连接的最大时间（秒）和最大请求数量。
// keep-alive的优点，减少延迟，避免每个请求都要重新建立TCP连接，提高效率，减少3次握手和4次挥手开销。节省资源，提高吞吐量。缺点是，长时期连接可能占用资源，影响系统性能。

// 浏览器的缓存机制

// 为什么需要缓存？
// 如果没有缓存机制，刷新页面的时候，不管是以什么样的形式刷新（前进/后退/普通刷新/强制刷新），那么每次浏览器都会去请求服务器的资源，想想是有多么的可怕，这样会大大的增加服务器的压力和带宽。

// 怎么查看资源的缓存策略？
// 在网络请求中，查看Size栏，disk cache表示磁盘缓存，memory cache走内存缓存。cache-control栏查看缓存策略。

// 强缓存和协商缓存：
// 强缓存是指通过Cache-control或expires进行判断资源是否过期，只有缓存失效后浏览器才会重新向服务器发起请求
// 协商缓存依赖于Last-Modified和Etag进行实现。浏览器每次请求某些资源时会带上某些标识，让服务器判断资源是否发生变化，如果没有发生变化，服务器会返回304 Not Modified让浏览器继续使用缓存资源，如果资源已经更新，则服务器返回新的资源。

//在实际开发中可以强缓存与协商缓存结合使用，如果缓存没过期，使用强缓存，如果缓存过期了，就使用协商缓存。浏览器先会根据cache-control先判断资源是否有效，有效->强缓存，失效->etag/last-modified。

// Expires和Cache-control的差别：
// Expires是http1.0的产物，Cache-control是1.1的产物，功能差不多，cache—control优先级高预Expires。Expires只是兼容性写法。
// Cache-Control：是最常用的缓存控制机制，用于控制缓存的行为。
// Cache-Control: no-store：不缓存。
// Cache-Control: no-cache：缓存但不使用缓存的数据，必须重新验证。
// Cache-Control: max-age：缓存多少秒。
// Cache-Control: public 和 private：定义缓存的范围，是公开缓存还是私有缓存。
// Etag浏览器和服务器通过对比资源的标识符来决定资源是否已经更改，如果没有更改，可以使用缓存。
// Last-Modified标记资源最后修改的时间，用来预服务器做比较，判断资源是否更新。Etag优先级高于Last-Modified。

// http缓存的应用场景：当服务器希望缓存静态资源如图片css，js时，可以使用http缓存机制，减少重复请求，提高性能。
// cookie存储会话信息，身份验证的信息，每次请求都会自动发送到服务器。
// localStorage，数据不会随着请求发送到服务器，适合存储用户设置，主题颜色等信息以及在多次会话间需要保持的数据。
// sessionStorage存储临时数据，例如用户在单次会话中填写的表单信息，分页状态等。

